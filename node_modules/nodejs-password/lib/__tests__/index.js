"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../");
const helpers_1 = require("../helpers");
let password, salt, passwordErrorMessage, saltErrorMessage;
beforeAll(() => {
    password = 'password';
    salt = 'salt';
    passwordErrorMessage = 'Password is empty';
    saltErrorMessage = 'Salt is empty';
});
describe('passwordHash', () => {
    test('should handle errors', () => {
        expect.assertions(2);
        expect(__1.passwordHash('', salt)).rejects.toEqual(new Error(passwordErrorMessage));
        expect(__1.passwordHash(password, '')).rejects.toEqual(new Error(saltErrorMessage));
    });
    test('should resolve a string', () => __awaiter(void 0, void 0, void 0, function* () {
        const hashedPassword = yield __1.passwordHash(password, salt, { length: 9 });
        expect(typeof hashedPassword).toBe('string');
    }));
});
describe('passwordVerify', () => {
    let hash;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        hash = (yield __1.passwordHash(password, salt));
    }));
    test('should resolve boolean', () => __awaiter(void 0, void 0, void 0, function* () {
        const isPasswordMatch = yield __1.passwordVerify(password, hash, salt);
        expect(typeof isPasswordMatch).toBe('boolean');
    }));
    test('should verify if password match the hashed value or note', () => __awaiter(void 0, void 0, void 0, function* () {
        let isPasswordMatch = yield __1.passwordVerify(password, hash, salt);
        expect(isPasswordMatch).toBeTruthy();
        isPasswordMatch = yield __1.passwordVerify('other password', hash, salt);
        expect(isPasswordMatch).toBeFalsy();
    }));
    test('accept the 4th params', () => __awaiter(void 0, void 0, void 0, function* () {
        const opts = { length: 9 };
        try {
            const hashedPassword = yield __1.passwordHash(password, salt, opts);
            expect(__1.passwordVerify(password, hashedPassword, salt, opts)).resolves.toBe(true);
            expect(__1.passwordVerify(password, hashedPassword, salt)).resolves.toBe(false);
        }
        catch (e) { }
    }));
});
describe('password_hash', () => {
    test('should work without salt param', () => {
        expect(__1.password_hash(password)).resolves.toBeTruthy();
    });
    test('should resolved hash be of type string', () => __awaiter(void 0, void 0, void 0, function* () {
        const hash = yield __1.password_hash(password);
        expect(typeof hash).toEqual('string');
    }));
    test('should work with different options like algo and length', () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const hash = yield __1.password_hash(password);
            const hashSha512 = yield __1.password_hash(password, {
                algo: helpers_1.HASH_ALGO.SHA512,
                length: 70,
            });
            const hashLength = yield __1.password_hash(password, {
                algo: helpers_1.HASH_ALGO.SHA256,
                length: 70,
            });
            expect(hash === hashSha512).toBeFalsy();
            expect(hash === hashLength).toBeFalsy();
        }
        catch (error) { }
    }));
});
describe('password_verify', () => {
    let hash, isPasswordMatch;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
            hash = (yield __1.password_hash(password));
            isPasswordMatch = yield __1.password_verify(password, hash);
        }
        catch (error) { }
    }));
    test('should resolve a boolean', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(typeof isPasswordMatch).toEqual('boolean');
    }));
    test('should password match a hash', () => {
        expect(isPasswordMatch).toBeTruthy();
    });
    test('should password not match a hash', () => __awaiter(void 0, void 0, void 0, function* () {
        let isPasswordMatch = yield __1.password_verify('other-password', hash);
        expect(isPasswordMatch).toBe(false);
    }));
    test('should verify if password match hash value with options params', () => __awaiter(void 0, void 0, void 0, function* () {
        const opts = {
            length: 70,
            algo: helpers_1.HASH_ALGO.SHA512,
        };
        const hash = yield __1.password_hash(password, opts);
        const isPasswordMatch = yield __1.password_verify(password, hash, opts);
        expect(isPasswordMatch).toEqual(true);
    }));
    test('should pass the same options value to both password_hash and password_verify', () => __awaiter(void 0, void 0, void 0, function* () {
        const opts = {
            length: 70,
            algo: helpers_1.HASH_ALGO.SHA512,
        };
        const hash = yield __1.password_hash(password, opts);
        const isPasswordMatch = yield __1.password_verify(password, hash);
        expect(isPasswordMatch).toEqual(false);
    }));
});
//# sourceMappingURL=index.js.map