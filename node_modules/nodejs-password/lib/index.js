"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const helpers_1 = require("./helpers");
const PHOD = { length: 64 };
/**
 * hash a password
 * @param password
 * @param salt
 * @param options
 * @version 1.0.0
 */
exports.passwordHash = (password, salt, options = PHOD) => {
    return new Promise((resolve, reject) => {
        const _type = 'base64';
        if (password.length < 1)
            reject(new Error(`Password is empty`));
        if (salt.length < 1)
            reject(new Error(`Salt is empty`));
        if (options.length < 1)
            reject(new Error(`Length must be greater than 0`));
        crypto_1.scrypt(password, salt, options.length, (err, buffer) => {
            if (err)
                reject(err);
            let hash = buffer.toString(_type);
            hash = hash.substring(0, options.length);
            resolve(hash);
        });
    });
};
/**
 * check if password match hash value
 * @param password password to check
 * @param hash hashed value to compare in most cases hashed password saved on some storage like DB..
 * @param salt salt used to hash the origin value in hash param
 * @version 1.0.0
 */
exports.passwordVerify = (password, hash, salt, options = PHOD) => {
    return new Promise((resolve) => __awaiter(void 0, void 0, void 0, function* () {
        let _hash = yield exports.passwordHash(password, salt, options);
        resolve(_hash === hash);
    }));
};
const P_HOD = { algo: helpers_1.HASH_ALGO.SHA256, length: 64 };
/**
 * hash a string passed as param
 * @param password
 * @returns {Promise<string>}
 */
exports.password_hash = (password, options = P_HOD) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (typeof password !== 'string')
            reject(new Error('password_hash accept first param to be a string'));
        const _buffer = Buffer.alloc(password.length, password);
        const _type = 'base64';
        let _salt = _buffer.toString(_type);
        let _hash = crypto_1.createHash(options.algo);
        let _result;
        _hash.update(_salt);
        _salt = _hash.digest(_type);
        crypto_1.scrypt(password, _salt, options.length, (err, buffer) => {
            if (err)
                reject(err);
            _result = buffer.toString(_type);
            _result = _result.replace(/=*$/, '');
            _result = '$2y$' + _result;
            resolve(_result);
        });
    }));
};
/**
 * compare a password with hashed value
 * @param password
 * @param hash hashed password to compare with
 * @param options list of optional options
 * @returns {Promise<boolean>} true if match otherwise false
 * @throws error in case something went wrong
 */
exports.password_verify = (password, hash, options = P_HOD) => {
    return new Promise((resolve) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            let _hash = yield exports.password_hash(password, options);
            resolve(_hash === hash);
        }
        catch (error) {
            resolve(false);
            throw new Error(error);
        }
    }));
};
//# sourceMappingURL=index.js.map